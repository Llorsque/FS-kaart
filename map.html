<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Schoolschaatsen ‚Äì Kaart (v5)</title>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
</head>
<body>
  <div class="topbar">
    <div class="left">
      <a class="btn btn-small" href="dashboard.html">‚Üî Naar Dashboard</a>
      <button id="toggleModeBtn" class="btn btn-small btn-ghost">üì± Mobile</button>
    </div>
    <div class="right">
      <a class="btn btn-small btn-ghost" href="index.html">üè† Start</a>
    </div>
  </div>

  <div class="container">
    <aside class="sidebar">
      <header>
        <h1>üó∫Ô∏è Kaart</h1>
        <p class="sub">Upload Excel ‚Üí geocoding (met fallback) ‚Üí filteren ‚Üí markers + aantallen.</p>
      </header>
      <section class="card controls">
        <div class="row">
          <input type="file" id="fileInput" accept=".xlsx,.xls" />
          <button id="clearCacheBtn" type="button">Cache legen</button>
        </div>
        <div class="row">
          <label>Geocoder:
            <select id="geocoderSel">
              <option value="pdok_first">PDOK ‚Üí Nominatim (fallback)</option>
              <option value="nominatim_first">Nominatim ‚Üí PDOK (fallback)</option>
              <option value="pdok_only">Alleen PDOK</option>
              <option value="nominatim_only">Alleen Nominatim</option>
            </select>
          </label>
          <label>Throttle (ms):
            <input type="number" id="throttleMs" value="200" min="0" step="50"/>
          </label>
          <button id="downloadCsvBtn" type="button" disabled>Download CSV</button>
          <button id="downloadXlsxBtn" type="button" disabled>Download Excel</button>
        </div>
        <div class="row">
          <div style="width:100%">
            <div id="progressText" class="muted">Nog geen bestand ge√ºpload.</div>
            <div class="progress"><div id="progressBar" class="progressbar"></div></div>
          </div>
        </div>
        <div class="row"><strong>Filters</strong></div>
        <div id="dynamicFilters" class="filters-block"></div>
        <div class="row">
          <button id="applyFiltersBtn" type="button">Filters toepassen</button>
          <button id="resetFiltersBtn" type="button">Reset</button>
        </div>
      </section>
      <section class="card">
        <h3 style="margin-top:0">Live aantallen</h3>
        <div class="kpis">
          <div class="kpi"><div class="label">Totaal (gefilterd)</div><div id="k_total" class="n">‚Äì</div></div>
          <div class="kpi"><div class="label">Geocodeerd</div><div id="k_geo" class="n">‚Äì</div></div>
        </div>
        <div style="margin-top:8px">
          <div class="legend" id="yearPills"></div>
        </div>
      </section>
      <section class="card table">
        <table id="previewTable">
          <thead></thead>
          <tbody></tbody>
        </table>
      </section>
    </aside>
    <main class="main">
      <div id="map"></div>
    </main>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="utils.js"></script>
  <script>
  ensureModePopup();
  const toggleModeBtn = document.getElementById('toggleModeBtn');
  toggleModeBtn.onclick = ()=>{
    const current = document.body.classList.contains('mobile') ? 'mobile' : 'desktop';
    applyMode(current==='mobile' ? 'desktop' : 'mobile');
    toggleModeBtn.textContent = document.body.classList.contains('mobile') ? 'üñ•Ô∏è Desktop' : 'üì± Mobile';
  };
  toggleModeBtn.textContent = document.body.classList.contains('mobile') ? 'üñ•Ô∏è Desktop' : 'üì± Mobile';

  const progressText = document.getElementById('progressText');
  const progressBar = document.getElementById('progressBar');
  updateProgress = (c,t,p)=>{
    const pct = t? Math.round((c/t)*100):0;
    progressText.textContent = t? `${p}: ${c}/${t} (${pct}%)` : 'Gereed.';
    progressBar.style.width = pct + '%';
  };

  const map = L.map('map').setView([52.2,5.3],7);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19}).addTo(map);
  const markerGroup = L.markerClusterGroup({ spiderfyOnMaxZoom:true }).addTo(map);
  let allRows = []; let filtered = []; let yearSeasons=[]; let filterPredicate = ()=>true;

  const fileInput = document.getElementById('fileInput');
  const clearCacheBtn = document.getElementById('clearCacheBtn');
  const geocoderSel = document.getElementById('geocoderSel');
  const throttleMs = document.getElementById('throttleMs');
  const downloadCsvBtn = document.getElementById('downloadCsvBtn');
  const downloadXlsxBtn = document.getElementById('downloadXlsxBtn');
  const applyFiltersBtn = document.getElementById('applyFiltersBtn');
  const resetFiltersBtn = document.getElementById('resetFiltersBtn');
  const k_total = document.getElementById('k_total');
  const k_geo = document.getElementById('k_geo');
  const yearPills = document.getElementById('yearPills');
  const tblHead = document.querySelector('#previewTable thead');
  const tblBody = document.querySelector('#previewTable tbody');

  function renderTable(rows){
    tblHead.innerHTML=''; tblBody.innerHTML='';
    if(!rows.length) return;
    const cols = Object.keys(rows[0]);
    const tr = document.createElement('tr');
    cols.forEach(c=>{ const th=document.createElement('th'); th.textContent=c; tr.appendChild(th); });
    tblHead.appendChild(tr);
    rows.slice(0,50).forEach(r=>{
      const tr = document.createElement('tr');
      cols.forEach(c=>{ const td=document.createElement('td'); td.textContent = r[c] ?? ''; tr.appendChild(td); });
      tblBody.appendChild(tr);
    });
  }

  function applyFilters(){
    filtered = allRows.filter(filterPredicate);
    renderMap(filtered);
    renderKPIs(filtered);
    renderTable(filtered);
  }
  function resetFilters(){
    document.getElementById('dynamicFilters').querySelectorAll('select, input[type=checkbox], input[type=number]').forEach(el=>{
      if(el.type==='checkbox') el.checked=false; else el.value='';
    });
    applyFilters();
  }

  function renderKPIs(rows){
    k_total.textContent = rows.length;
    const geoN = rows.filter(r=>r.lat&&r.lon).length;
    k_geo.textContent = geoN;
    yearPills.innerHTML='';
    for(const s of yearSeasons){
      const n = rows.reduce((acc,r)=> acc + (r['_season__'+s]===true?1:0), 0);
      const div = document.createElement('div'); div.className='pill'; div.textContent = `${s}: ${n}`;
      yearPills.appendChild(div);
    }
  }

  function escapeHtml(s){ return String(s??'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
  function buildPopup(row){
    const title = row['NAAM SCHOOL'] || row.Naam || row.naam || row.School || row.school || 'Onbekend';
    const pairs = Object.entries(row).filter(([k,v])=>!['_leaflet_id'].includes(k)).map(([k,v])=>`<tr><th style="text-align:left;padding-right:8px">${escapeHtml(k)}</th><td>${escapeHtml(v)}</td></tr>`).join('');
    return `<div><strong>${escapeHtml(title)}</strong><br/><table>${pairs}</table></div>`;
  }

  function renderMap(rows){
    markerGroup.clearLayers();
    const markers = [];
    for(const r of rows){
      if(!(r.lat && r.lon)) continue;
      const m = L.marker([r.lat, r.lon]);
      m.bindPopup(buildPopup(r));
      markerGroup.addLayer(m);
      markers.push(m);
    }
    if(markers.length){
      const grp = L.featureGroup(markers);
      map.fitBounds(grp.getBounds().pad(0.12));
    }
  }

  // ===== Robust geocoding with fallback & better query =====
  function norm(s){ return (s||'').toString().trim(); }
  function buildAddress(r){
    const straat = norm(r.ADRES||r.Adres||r.adres);
    const huisnr = norm(r['HUISNUMMER']||r['Huisnummer']||r['huisnummer']||'');
    const toevoeg = norm(r['HUISNUMMER-TOEVOEGING']||r['Huisnummer-toevoeging']||r['huisnummer-toevoeging']||'');
    const straatFull = [straat, [huisnr, toevoeg].filter(Boolean).join('')].filter(Boolean).join(' ');
    let pc = norm(r.POSTCODE||r.Postcode||r.postcode).replace(/\s+/g,'');
    if(pc && pc.length===6){ pc = pc.slice(0,4)+' '+pc.slice(4); }
    const plaats = norm(r.PLAATSNAAM||r.Plaats||r.plaats||r.GEMEENTENAAM||r.gemeente);
    const prov = norm(r.PROVINCIE||r.Provincie||r.provincie);
    return [straatFull, pc, plaats, prov, 'Nederland'].filter(Boolean).join(', ');
  }
  function cacheGet(key){ try{ return JSON.parse(localStorage.getItem('geo_cache_v2')||'{}')[key]||null; }catch{ return null; } }
  function cacheSet(key,val){ try{ const c = JSON.parse(localStorage.getItem('geo_cache_v2')||'{}'); c[key]=val; localStorage.setItem('geo_cache_v2', JSON.stringify(c)); }catch{} }
  async function geocodeNominatim(query){
    const params = new URLSearchParams({format:'jsonv2',q:query,addressdetails:'0',limit:'1',countrycodes:'nl','accept-language':'nl'});
    const url = `https://nominatim.openstreetmap.org/search?${params.toString()}`;
    const res = await fetch(url,{headers:{'Accept':'application/json'}});
    if(!res.ok) throw new Error('Nominatim '+res.status);
    const json = await res.json();
    if(Array.isArray(json)&&json.length){ return {lat:parseFloat(json[0].lat), lon:parseFloat(json[0].lon)}; }
    return {lat:null, lon:null};
  }
  async function geocodePDOK(query){
    const params = new URLSearchParams({q:query, wt:'json'});
    const url = `https://geodata.nationaalgeoregister.nl/locatieserver/v3/free?${params.toString()}`;
    const res = await fetch(url,{headers:{'Accept':'application/json'}});
    if(!res.ok) throw new Error('PDOK '+res.status);
    const json = await res.json();
    const doc = json && json.response && json.response.docs && json.response.docs[0];
    if(doc && doc.centroide_ll){
      const m = doc.centroide_ll.match(/POINT\(([-\d\.]+)\s+([\-\d\.]+)\)/);
      if(m){ return {lat:parseFloat(m[2]), lon:parseFloat(m[1])}; }
    }
    return {lat:null, lon:null};
  }
  async function geocodeWithFallback(query, strategy){
    if(strategy==='pdok_only') return geocodePDOK(query);
    if(strategy==='nominatim_only') return geocodeNominatim(query);
    if(strategy==='pdok_first'){
      const a = await geocodePDOK(query); if(a.lat&&a.lon) return a; return geocodeNominatim(query);
    }
    if(strategy==='nominatim_first'){
      const a = await geocodeNominatim(query); if(a.lat&&a.lon) return a; return geocodePDOK(query);
    }
    return geocodePDOK(query);
  }

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  async function geocodeRows(rows){
    const total = rows.length; let done=0; updateProgress(0,total,'Geocoding');
    const out = [];
    const strategy = geocoderSel.value;
    const wait = parseInt(throttleMs.value||'200',10);

    for(const r of rows){
      const query = buildAddress(r);
      if(!query || query === ', Nederland'){
        out.push({...r, lat:null, lon:null}); done++; updateProgress(done,total,'Geocoding'); continue;
      }
      const key = query.toLowerCase();
      let loc = cacheGet(key);
      if(!loc){
        try{
          loc = await geocodeWithFallback(query, strategy);
        }catch(e){
          console.error('Geocode fout', query, e);
          // fallback on city+postcode only
          const pc = (r.POSTCODE||r.postcode||'').toString();
          const plaats = (r.PLAATSNAAM||r.plaats||r.GEMEENTENAAM||'').toString();
          const q2 = [pc, plaats, 'Nederland'].filter(Boolean).join(', ');
          try{ loc = await geocodeWithFallback(q2, strategy); }catch{ loc = {lat:null, lon:null}; }
        }
        cacheSet(key, loc);
        if(wait>0) await sleep(wait);
      }
      out.push({...r, lat:loc.lat, lon:loc.lon});
      done++; updateProgress(done,total,'Geocoding');
    }
    return out;
  }

  function toCSV(rows){
    const headers = Object.keys(rows[0]||{});
    const lines = [headers.join(',')];
    for(const r of rows){
      const vals = headers.map(h=>{
        const s = String(r[h]??'');
        return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
      });
      lines.push(vals.join(','));
    }
    return lines.join('\n');
  }

  function buildFilters(rows){
    const excluded = new Set(['NAAM SCHOOL','Naam','naam','ADRES','Adres','adres','POSTCODE','Postcode','postcode','PROVINCIE','Provincie','provincie','HUISNUMMER-TOEVOEGING','PLAATSNAAM CORRESPONDENTIEADRES']);
    return buildDynamicFilters(rows, yearSeasons, {excludedColumns: excluded});
  }

  async function handleFile(file){
    progressText.textContent = 'Bestand lezen...'; progressBar.style.width='0%';
    const data = await file.arrayBuffer();
    const wb = XLSX.read(data,{type:'array'});
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(ws, {defval:''});
    if(!rows.length){ progressText.textContent='Leeg bestand.'; return; }

    const derived = deriveSeasonsAndFlags(rows);
    yearSeasons = derived.yearSeasons;
    let enriched = derived.rows;

    const withGeo = await geocodeRows(enriched);
    allRows = withGeo;

    filterPredicate = buildFilters(allRows);
    applyFilters();

    progressText.textContent = `Gereed. Geocodeerd: ${allRows.filter(r=>r.lat&&r.lon).length}/${allRows.length}`;
    progressBar.style.width='100%';
    downloadCsvBtn.disabled = false;
    downloadXlsxBtn.disabled = false;
  }

  document.getElementById('fileInput').addEventListener('change', e=>{const f=e.target.files?.[0]; if(f) handleFile(f);});
  document.getElementById('clearCacheBtn').addEventListener('click', ()=>{ localStorage.removeItem('geo_cache_v2'); alert('Geocoding-cache geleegd.'); });
  document.getElementById('applyFiltersBtn').addEventListener('click', applyFilters);
  document.getElementById('resetFiltersBtn').addEventListener('click', resetFilters);

  downloadCsvBtn.addEventListener('click', ()=>{
    const csv = toCSV(allRows);
    const blob = new Blob([csv],{type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='geocoded_export.csv'; a.click(); URL.revokeObjectURL(url);
  });
  downloadXlsxBtn.addEventListener('click', ()=> exportXLSX(allRows, 'geocoded_export.xlsx'));
  </script>
</body>
</html>
